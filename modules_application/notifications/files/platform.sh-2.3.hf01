#!/bin/bash

# Source the globals.
LOCAL_DIR=`dirname $0`
. ${LOCAL_DIR}/common.sh

# Setup environment
if [ "x${PLATFORM_HOME}" = "x" ]; then
	PLATFORM_HOME=`dirname ${0}`/..
fi
if [ "x${PLATFORM_NAME}" = "x" ]; then
        PLATFORM_NAME=`basename ${PLATFORM_HOME}`
fi
if [ "x${PLATFORM_JVM_FORK}" = "x" ]; then
	PLATFORM_JVM_FORK=yes
fi
if [ "x${PLATFORM_JVM_DEBUG}" = "x" ]; then
	PLATFORM_JVM_DEBUG=no
fi
if [ "x${PLATFORM_JVM_JDBPORT}" = "x" ]; then
	PLATFORM_JVM_JDBPORT=15555
fi
if [ "x${PLATFORM_JVM_HEAP}" = "x" ]; then
    PLATFORM_JVM_HEAP="1024m"
fi
if [ "x${PLATFORM_JVM_OFFHEAP}" = "x" ]; then
    PLATFORM_JVM_OFFHEAP="64m"
fi
if [ "x${PLATFORM_JVM_ARGS}" = "x" ]; then
	PLATFORM_JVM_ARGS=" "
fi
if [ "x${JAVA_HOME}" = "x" ]; then
	JAVA_HOME=$JDK_INSTALL_LINK
fi
if [ "x${PLATFORM_NAME}" = "x" ]; then
	PLATFORM_NAME="nmp"
fi
if [ "x${PLATFORM_INSTALL}" = "x" ]; then
	PLATFORM_INSTALL=${PLATFORM_HOME}
fi
if [ "x${PLATFORM_ADDITIONAL_CLASSPATH}" = "x" ]; then
	PLATFORM_ADDITIONAL_CLASSPATH=${PLATFORM_HOME}
fi
if [ "x${PLATFORM_USER}" = "x" ]; then
	PLATFORM_USER="ozimps"
fi
if [ "x${PLATFORM_DNS_CACHE_TTL_SEC}" = "x" ]; then
	PLATFORM_DNS_CACHE_TTL_SEC="30"
fi

# Source the environment overrides
if [ -f ${PLATFORM_HOME}/platform.env ]; then
	. ${PLATFORM_HOME}/platform.env
fi

# Configure classpath
FELIX_VERSION="3.0.6"
PLATFORM_CLASSPATH="${PLATFORM_ADDITIONAL_CLASSPATH}:${PLATFORM_INSTALL}/repository/org.apache.felix-${FELIX_VERSION}.jar:${PLATFORM_INSTALL}/repository/com.nokia.nmp.container.jar"

# Handle cygwin paths
case `uname -a` in
	*Cygwin*|*CYGWIN*)
		PLATFORM_CLASSPATH=`cygpath --path --mixed ${PLATFORM_CLASSPATH}`
		PLATFORM_HOME=`cygpath --mixed ${PLATFORM_HOME}`
		PLATFORM_INSTALL=`cygpath --mixed ${PLATFORM_INSTALL}`
		;;
	*)
esac

# Configure command line
PLATFORM_CMDLINE=""
if [ "$PLATFORM_JVM_DEBUG" = "yes" ]; then
	PLATFORM_CMDLINE="${PLATFORM_CMDLINE} \
	 -Xdebug -Xnoagent -Djava.compiler=NONE \
	 -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=${PLATFORM_JVM_JDBPORT}"
fi
PLATFORM_CMDLINE="${PLATFORM_CMDLINE} \
 -server \
 -XX:-OmitStackTraceInFastThrow \
 -XX:ErrorFile=${PLATFORM_WORK}/hs_err_pid.log \
 -XX:-HeapDumpOnOutOfMemoryError \
 -XX:HeapDumpPath=${PLATFORM_WORK}/out_of_memory.hprof \
 -XX:MaxDirectMemorySize=${PLATFORM_JVM_OFFHEAP} \
 -Xmx${PLATFORM_JVM_HEAP} \
 -Xms${PLATFORM_JVM_HEAP} \
 ${PLATFORM_JVM_ARGS} \
 -Djava.net.preferIPv4Stack=true \
 -Dsun.net.inetaddr.ttl=${PLATFORM_DNS_CACHE_TTL_SEC} \
 -Dcom.nokia.nmp.home=${PLATFORM_HOME} \
 -Dcom.nokia.nmp.install=${PLATFORM_INSTALL} \
 -Dcom.nokia.nmp.work=${PLATFORM_WORK} \
 -Dcom.nokia.nmp.name=${PLATFORM_NAME} \
 -cp ${PLATFORM_CLASSPATH} \
 com.nokia.nmp.osgi.felix.FelixLauncher"

# Check user
check_user()
{
	WHOAMI=`whoami`
	if [ "$WHOAMI" != "$PLATFORM_USER" ]; then
		return 1
	fi
	return 0
}

# Check jdk
check_jdk()
{
	if nmp_jdk_check ${JDK_VENDOR_SUN} 1.7; then
		return 0
	fi
	return 1
}

# Get pid
get_pid() {
	local PID=""
	case `uname -a` in
		*cygwin*|*Cygwin*)
			PID=`cat ${PLATFORM_WORK}/platform.pid 2>/dev/null`
			;;
		*)
			EXTRACT_PID='ps -eo pid,ppid,command | grep ${JAVA_HOME} | egrep "Dcom.nokia.nmp.name=${PLATFORM_NAME} " | head -n 1 | awk "{print \$1}"'
 			PID=`eval ${EXTRACT_PID}`
 			;;
	esac
	# Last chance - take whatever is in the PID file
	if [ "x${PID}" = "x" ]; then
		PID=`cat ${PLATFORM_WORK}/platform.pid 2>/dev/null`
	fi
 	echo ${PID}
}

# Check running
check_running()
{
    local PID=$1
    if [ "x$PID" = "x" ]; then
         PID=`get_pid`
    fi
 	if [ "x$PID" != "x" ] && /bin/kill -0 $PID 2>/dev/null ; then
		return 0
 	else
    	return 1
	fi
}

# Write PID
# Args:
#  PID of the platform.
write_pid() {
    local PID=$1
 	echo $PID > ${PLATFORM_WORK}/platform.pid
}

# Kill from pid
kill_pid()
{
  	local PID=$1
  	if [ "x$PID" = "x" ]; then
  	     PID=`get_pid`
  	fi
 	if [ "x$PID" != "x" ] && /bin/kill -0 $PID 2>/dev/null ; then
    	kill -9 ${PID}
 	fi
}

# Rotate stderr logs
rotate_logs()
{
	# Get log indexes & rotate
	local IDXS=`ls -1 ${PLATFORM_WORK}/stderr.log.* 2>/dev/null | sed -e 's/.*stderr\.log\.//g' | sort -gr`
	for IDX in $IDXS
	do
		local IDXP=`expr $IDX + 1`
		# We keep only 10 logs
		if [ $IDX -ge 10 ]; then
			rm -f ${PLATFORM_WORK}/stderr.log.$IDX
		else
			mv ${PLATFORM_WORK}/stderr.log.$IDX ${PLATFORM_WORK}/stderr.log.$IDXP
		fi
	done
	# Roll the current to next number
	if [ -f ${PLATFORM_WORK}/stderr.log ]; then
		mv -f ${PLATFORM_WORK}/stderr.log ${PLATFORM_WORK}/stderr.log.1
	fi
}

# Execute a JMX operation
jmx()
{
	local NAME=$1
	local OPERATION=$2
	local CONTEXT=$3
	# Get the JMX properties
 	JMXPORT=`cat ${PLATFORM_HOME}/platform.properties | grep "jmx.connector.port" | sed -e's/.*= *\([0-9][0-9]*\) */\1/g'`
 	JMXHOST=`cat ${PLATFORM_HOME}/platform.properties | grep "jmx.connector.ip" | sed -e's/.*= *\([^ ]*\) */\1/g'`
 	# Execute the operation
 	${JAVA_HOME}/bin/java -jar ${PLATFORM_INSTALL}/bin/jmx-client.jar "${JMXHOST}:${JMXPORT}" "${NAME}" "${OPERATION}" -c "${CONTEXT}" 1>/dev/null 2>&1
}

# Switch state - the state scheme is not perfect as we use a single central
# file for state storage
set_state()
{
    local STATE=$1
    echo $STATE > ${PLATFORM_WORK}/platform.state
}

# Check state
check_state()
{
    local STATE=$1
    if [ -f ${PLATFORM_WORK}/platform.state ]; then
        if grep $STATE ${PLATFORM_WORK}/platform.state 1>/dev/null 2>&1; then
            return 0
        fi
    fi
    return 1
}
    
# Start the platform
start()
{
	local NAME=${PLATFORM_NAME}
	
	# If platform is stopping, give it some time to do it
	if check_state STOPPING; then
	    local count=0
        while check_running;
        do
            sleep 1
            count=`expr $count + 1`
            if [ $count -ge 10 ]; then
                break;
  	  	    fi
 	  	done
 	fi
 	
 	# Final check for running 
    if check_running; then
            # Server is (still) running
            echo "The instance [$NAME] is already started."
        return 0
    fi
 	
    # If platform is already starting, don't start twice
    if check_state STARTING; then
        echo "The instance [$NAME] is already starting."
        return 0
    fi

    echo "Starting instance [${NAME}]."
    set_state STARTING
    
	# Cleanup folders
	rm -rf ${PLATFORM_HOME}/cache
	rm -rf ${PLATFORM_HOME}/deploy

	# Save previous stderr.log
	rotate_logs

	# Start
	echo "Platform start: "`date` > ${PLATFORM_WORK}/stderr.log
	cd ${PLATFORM_HOME}
 	if ! check_jdk; then
 		echo "ERROR: JDK installation at ${JAVA_HOME} doesn't point to a suitable JDK." >> ${PLATFORM_WORK}/stderr.log
		echo "ERROR: JDK installation at ${JAVA_HOME} doesn't point to a suitable JDK."
		set_state STOPPED
		return 0
 	fi
	if [ "${PLATFORM_JVM_FORK}" = "yes" ]; then
		nohup ${JAVA_HOME}/bin/java ${PLATFORM_CMDLINE} >> ${PLATFORM_WORK}/stderr.log 2>&1 &
	else
		${JAVA_HOME}/bin/java ${PLATFORM_CMDLINE} 2>&1 | tee -a ${PLATFORM_WORK}/stderr.log
	fi
	
	# Save pid for monit
	write_pid $!	
	local PID=`get_pid`
	
	set_state STARTED
	echo "Started (PID=$PID)."
}

# Stop the platform
stop()
{
	local NAME=${PLATFORM_NAME}

    # If platform is already stopping, don't stop twice
    if check_state STOPPING; then
        echo "The instance [$NAME] is already stopping."
        return 0
    fi
 
    # If platform is starting, give it some time to do it
    if check_state STARTING; then
        local count=0
        while ! check_running;
        do
            sleep 1
            count=`expr $count + 1`
            if [ $count -ge 10 ]; then
                break;
            fi
        done
    fi

    # Final check        
    if ! check_running; then
            # Server is stopped
            echo "The instance [$NAME] is already stopped."
        return 0
    fi

    echo "Stopping instance [$NAME]."
    set_state STOPPING
     	
 	# Try a clean shutdown via JMX
 	local PID=`get_pid`
 	cd ${PLATFORM_HOME}
 	jmx 'com.nokia.nmp:type=Command,name=OzShutdown' 'execute((java.lang.String)"")' 'platform' 2>&1 1>/dev/null
 	
 	# Give it some time to exit
 	local count=0
 	while check_running $PID;
 	do
 		sleep 1
 		count=`expr $count + 1`
 		if [ $count -gt 5 ]; then
 			# Do a hard kill
	 		kill_pid $PID
            if [ "x$PID" != x ]; then
                if grep $PID ${PLATFORM_WORK}/platform.pid 1>/dev/null 2>&1 ]; then
                    rm -f ${PLATFORM_WORK}/platform.pid
                fi
            fi
 		fi
 	done 	
 	
 	set_state STOPPED
 	echo "Stopped (PID=${PID})."
 	echo "Platform stop: "`date` >> ${PLATFORM_WORK}/stderr.log 	
}

# Restart the platform
restart()
{
	stop
	start
}

# Reload configuration
reload()
{
	echo "Reloading configuration."
	jmx "com.nokia.nmp.configuration:name=Configuration" "updateConfiguration()" "configuration" 2>&1 1>/dev/null
	echo "Done."
}

# Sends a command to get executed
send-command()
{
    shift
    local INSTANCE=$1
    shift    
    local ARGS=$*
    if [ $# -gt 0 ]; then
        echo "Sending command."
        jmx "com.nokia.nmp.nodes.command:type=NmpCommandService,name=CommandService-${INSTANCE}" "executeCommand((java.lang.String) ${ARGS})" "" 2>&1 1>/dev/null
        echo "Done."
        return 0;
    else
        echo "Error: Missing command name."
        return 1;
    fi
}

# Check if platform is running
check()
{
	local NAME=${PLATFORM_NAME}
 	if check_running; then
 		echo "Instance [$NAME] is running (PID="`get_pid`")"
 		return 0
 	else
 		echo "Instance [$NAME] is stopped."
 		return 1
 	fi
}

# Outputs information on the platform
info()
{
	local ISRUNNING="STOPPED"
	if check_running; then
		ISRUNNING="RUNNING"
	fi
 	cat <<EOF
PLATFORM_NAME=${PLATFORM_NAME}
PLATFORM_HOME=${PLATFORM_HOME}
PLATFORM_WORK=${PLATFORM_WORK}
PLATFORM_RUNNING=$ISRUNNING
PLATFORM_PID=`get_pid`
PLATFORM_INSTALL=${PLATFORM_INSTALL}
PLATFORM_JVM_FORK=${PLATFORM_JVM_FORK}
PLATFORM_JVM_DEBUG=${PLATFORM_JVM_DEBUG}
PLATFORM_JVM_JDBPORT=${PLATFORM_JVM_JDBPORT}
PLATFORM_JVM_HEAP=${PLATFORM_JVM_HEAP}
PLATFORM_JVM_OFFHEAP=${PLATFORM_JVM_OFFHEAP}
PLATFORM_JVM_ARGS=${PLATFORM_JVM_ARGS}
PLATFORM_DNS_CACHE_TTL_SEC=${PLATFORM_DNS_CACHE_TTL_SEC}
JAVA_HOME=${JAVA_HOME}
JAVA_VERSION=`${JAVA_HOME}/bin/java -version 2>&1 | tail -1`
JAVA_CLASSPATH=${PLATFORM_CLASSPATH}
EOF
}

# Dumps heap or thread information (or both). The dump files are stored into a
# sub-directory, time-stamped.
# Args:
#  threads|heap|fds|all
#  dump directory
dump()
{
	local NAME=${PLATFORM_NAME}
 	if ! check_running; then
 		echo "Instance [$NAME] is not running."
 		return 1
 	fi
 	local DIR=$2
 	if [ "x$DIR" = "x" ]; then 
 		echo "Usage: dump <threads|heap|fds|all> <dump directory>"
 		return 1
 	fi
 	if [ ! -d $DIR ]; then
 		echo "$2 is not a directory."
 		return 1
 	fi
 	local DATE=`date +%y%m%d`
 	local TIME=`date +%H%M%S`
 	local DUMP_DIR=$DIR/$DATE
 	local PID=`get_pid` 	
 	case $1 in
 		threads|thread|t)
 			echo "Dumping threads state..."
 			mkdir -p $DUMP_DIR
 			${JAVA_HOME}/bin/jstack $PID > $DUMP_DIR/$NAME-threads-$TIME.dump 2>&1 
 			echo "Done."
 			;;
 		heap|h)
 			echo "Dumping heap state..."
 			mkdir -p $DUMP_DIR
 			${JAVA_HOME}/bin/jmap -heap $PID > $DUMP_DIR/$NAME-heap-$TIME.summary 2>&1 
 			${JAVA_HOME}/bin/jmap -histo $PID > $DUMP_DIR/$NAME-heap-$TIME.histo 2>&1 
 			${JAVA_HOME}/bin/jmap -dump:format=b,file=$DUMP_DIR/$NAME-heap-$TIME.hprof $PID > /dev/null 2>&1
 			echo "Done."
 			;;
 		heapsummary|hs)
            echo "Dumping heap summary..."
            mkdir -p $DUMP_DIR
            ${JAVA_HOME}/bin/jmap -heap $PID > $DUMP_DIR/$NAME-heap-$TIME.summary 2>&1 
            ${JAVA_HOME}/bin/jmap -histo $PID > $DUMP_DIR/$NAME-heap-$TIME.histo 2>&1  	
            echo "Done."
            ;;	 
 		fds|f)
 			echo "Dumping file descriptors state..."
 			mkdir -p $DUMP_DIR
 			ls -l /proc/$PID/fd > $DUMP_DIR/$NAME-fds-$TIME.summary 2>&1
 			echo "SYSTEM TOTAL:" >> $DUMP_DIR/$NAME-fds-$TIME.summary 2>&1
 			cat /proc/sys/fs/file-nr >> $DUMP_DIR/$NAME-fds-$TIME.summary 2>&1
 			echo "Done."
 			;;
 		all|a)
 			dump threads $DIR
 			dump fds $DIR
 			dump heap $DIR
 			;;
 		*)
 			echo "Unknown dump command $1"
 			return 1
 			;;
 	esac
 	return 0
}

# Set the platform log level
log()
{	
	local LOG_LEVEL=`echo $1 | sed -e's/ *//g'`
	local CURRENT_LEVEL=`grep 'log4j.logger.com.nokia=' ${PLATFORM_HOME}/log4j.properties | sed -e's/.*=\([a-zA-Z]+\).*/\1/'`
	if [ "x$LOG_LEVEL" = "x" ]; then
		echo "Current log level: $CURRENT_LEVEL"		
		return 1
	fi
	case $LOG_LEVEL in
		debug|DEBUG)
			LOG_LEVEL="DEBUG";;
		info|INFO)
			LOG_LEVEL="INFO";;
		warn|WARN|warning|WARNING)
			LOG_LEVEL="WARN";;
		error|ERROR|critical|CRITICAL|always|ALWAYS)
			LOG_LEVEL="ERROR";;
		*)
			echo "Unknown log level $LOG_LEVEL"
			return 1;;
	esac
    	if [ -f ${PLATFORM_HOME}/log4j.properties ] ; then
    		# If it's set, modify the line    	
    		if grep 'log4j.logger.com.nokia=' ${PLATFORM_HOME}/log4j.properties 2>&1 1>/dev/null ; then
	        	perl -pi -e s/logger.com.nokia=[a-zA-Z]+/logger.com.nokia=$LOG_LEVEL/ "${PLATFORM_HOME}/log4j.properties"
    		else
    			# Otherwise, add it
    			echo -e "\nlog4j.logger.com.nokia=$LOG_LEVEL" >> ${PLATFORM_HOME}/log4j.properties
			fi
            # same for myriadgroup package
    		if grep 'log4j.logger.com.myriadgroup=' ${PLATFORM_HOME}/log4j.properties 2>&1 1>/dev/null ; then
	        	perl -pi -e s/logger.com.myriadgroup=[a-zA-Z]+/logger.com.myriadgroup=$LOG_LEVEL/ "${PLATFORM_HOME}/log4j.properties"
    		else
    			# Otherwise, add it
    			echo -e "\nlog4j.logger.com.myriadgroup=$LOG_LEVEL" >> ${PLATFORM_HOME}/log4j.properties
			fi
		fi
	echo "Log level switched to: $LOG_LEVEL"
}

# Audit the system
audit()
{
	${PLATFORM_HOME}/bin/audit.sh ${PLATFORM_HOME} $*
}

# Check we run as NMP_USER
if ! check_user; then
	echo "You must be user $PLATFORM_USER to run this script."
	exit 1
fi

# Main 
case $1 in
	start)
		start
		;;
	stop)
		stop
		;;
	restart)
		restart
		;;
	check)
		check
		;;	
	info)
		info
		;;	
	dump)
		shift;
		dump $*
		;;	
 	log)
 		shift;
 		log $*
 		;;
 	audit)
 		shift;
 		audit $*
 		;;
 	jmx)
 		shift;
 		jmx $*
 		;;
 	reload)
		reload
		;;	
	send-command)
        	send-command $*
        	;;
	*)
		echo "Unknown command [$1]"
		exit -1
		;;
esac 
